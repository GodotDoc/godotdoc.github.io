[{"id":0,"href":"/docs/godot/","title":"Godot 入门","section":"Docs","content":"\rGDScript\r#\rGodot官方提供多种开发语言供开发者选择，如：GDScript、C# 、C/C++、其他。\nGDScript 是 Godot 专用的编程语言，具有设计简洁、学习曲线低、与Godot引擎紧密集成等优点，非常适合新手和独立开发者。\n如果你有其他面向对象语言开发基础，学习 GDScript 将会很快。\n代码\r#\rGDScript 代码长下面这个样子，先混个眼熟。\nextends Node2D # Called when the node enters the scene tree for the first time. func _ready(): pass # Replace with function body. # Called every frame. \u0026#39;delta\u0026#39; is the elapsed time since the previous frame. func _process(delta): pass "},{"id":1,"href":"/docs/godot/environment/","title":"GodotEngine 安装","section":"Godot 入门","content":"\r安装运行环境\r#\r工欲善其事必先利其器 ，学习 Godot 要先安装 Godot 游戏引擎。\n下载引擎\r#\r进入GodotEngine 官网\n你要使用最新版的就点击 Download Latest，要使用以前的版本就点击 previous version。\n下载 Godot 4.0\r#\r写此文的时候（2024-09-01）官方已经发布了 Godot4.3，但是本文将使用 Godot4.0 版本演示。读者可以根据自己的爱好选择版本，只要是 4.x 的版本在 GDScript 的使用上差别都不是特别大。\n如果你是新手，那么建议使用 4.x 以及以上的最新版本，如果你习惯使用 3.x 版本，那么你已经是老手，本文将会浪费你的宝贵时间。\n这里我们选择 Standard 标准版，如果是用 C# 开发的需要选择 .NET 版本。\n打开 Godot 4.0 新建项目\r#\r如果你是 windows 平台，将下载的压缩包解压后会看到两个文件。Godot_v4.0-stable_win64.exe 和 Godot_v4.0-stable_win64_console.exe，不用管其他的双击前者打开 Godot 引擎就行了（甚至不用安装），然后新建个项目名称随意。\n新建项目上方可以选择语言，如果默认不是中文可以在这里调整。 项目路径最好选择一个空的路径上没有中文和特殊字符的文件夹。 渲染器那三个选项可以默认的学习 GDScript 不用关心这个。 新建节点和脚本文件\r#\r新建完项目会自动打开，点击左侧的 2D 场景，新建一个写代码用的测试场景。\n在刚新建的 2D 场景上添加一个脚本，用于编写测试脚本。\n创建完成后会自动跳转到脚本编辑页面（此时还是未保存状态，可以按ctrl + s保存）。\n至此 GDScript 的运行环境已经安装完成了，读者可以在这里编写 GDScript 脚本了。\n附录\r#\r使用 Godot 编辑器\r#\rGodot 编辑器相较于 VSCode,Visual Studio 等非官方的编辑器还是相对比较简洁的。我们简单看一下。\n点击这里全屏显示 Godot 编辑器，沉浸式编写 GDScript 代码。 点击这里搜一些内置类、节点的使用文档（有中文哦，个人特别特别喜欢这个功能，非常有用）。 点击这里可以直接跳转到 Godot 的官方教程，不用再打开浏览器输入网址这么麻烦了。 这里列出了正打开的 GDScript 脚本文件。 这里列出了当前正在编辑的 GDScript 脚本中的方法，当一个方法比较多的时候，用这里可以快速找到某个方法。 Godot 节点和场景的区别\r#\r一个场景(Scene)是由一个节点树(Node Tree)构成的。每个场景需要有一个根节点(Root Node)和多个子节点(child node)。每个场景又可以当作其他场景的节点。（个人感觉节点跟场景是同一个东西，Godot万物皆节点，万物皆对象。）\nGodot 版本命名规范\r#\r如果你刚刚接触 Godot Engine ，你会发现它有很多版本。这是由于 Godot Engine 还在飞速发展中，所以版本更新会比较频繁。\n这里简单说一下 Godot Engine 的命名规范，以便读者可以选择自己适合的版本。\nGodot_vx.x-dev：开发版本，最早的版本，可以用来体验新功能。 Godot_vx.x-alpha：内测版，给内部人员测试用的，Bug多且功能也不全。 Godot_vx.x-beta：公测版，给一些非内部人员测试用，还有很多 BUG 还可能会增加新功能。 Godot_vx.x-rc：稳定版，功能已经稳定了（和stable一样）不再新添和减少功能，但还有些bug要修复。 Godot_vx.x-stable：稳定的最终发版，已知的严重bug都修复完了，正式项目一般用这个。 "},{"id":2,"href":"/docs/nodes/node2d/","title":"Node2d","section":"Godot节点手册","content":"\rNode2d\r#\r2D 游戏对象，具有变换（位置、旋转、缩放）等基本功能。所有的 2D 节点，包括物理对象和精灵，都继承自 Node2D。可以使用 Node2D 作为父节点来移动、缩放和旋转 2D 项目中的子节点。\n待完善\u0026hellip;\n"},{"id":3,"href":"/docs/case/platform_jump/","title":"平台跳跃游戏","section":"Godot 游戏案例","content":"\r平台跳跃游戏\r#\r待完善\u0026hellip;\n"},{"id":4,"href":"/docs/tips/pixel_game_setting/","title":"像素风格游戏配置","section":"Godot 小技巧","content":"\r像素风游戏配置\r#\r"},{"id":5,"href":"/docs/godot/basic_grammar/","title":"GDScript 语法参考","section":"Godot 入门","content":"\rGDScript 语法参考\r#\rGDScript 的语法很简单，下面通过一些案例帮助读者快速的入门 GDScript。\n本文默认读者至少有少许的编程经验，知道变量、常量、对象和类等词是什么意思。\n没有特殊说明，下文的代码都是在 func _ready(): 方法中编写的，然后点击右上角可以运行看效果。\n变量\r#\r变量是用于存储信息的\u0026quot;容器\u0026quot;，这个\u0026quot;容器\u0026quot;储存的数据可以在游戏运行时随时更改，使用 var 关键定义。\n# 定义一个叫 n 的变量 var n = 1 # 使用冒号和数据类型关键字手动声明变量类型 var n1 : int = 1 # 可以省略类型关键字，系统会自动推断 var n2 : = 1 # 修改变量值 n = 2 n1 = 2 n2 = 2 是否声明变量类型根据自己喜好来。笔者觉得声明变量类型使用起来比较方便，不声明类型代码看起来简洁。\n常量\r#\r常量是在游戏运行时无法更改的值，使用关键字 const 定义。\n# 常量就是定义了就不能修改的数据\u0026#34;容器\u0026#34; const A = 1 注释\r#\r注释是用来给程序员看的\u0026quot;代码\u0026quot;，不会被系统编译，相当于代码的备忘录，使用关键字 #。\n# 这里就是一条注释，可以理解为代码的备忘录，程序运行的时候，会把这行删掉。 var n = 1 const N = 1 从 Godot4.2 开始，可以使用双井号 ## 注释。\n双井号注释被称为\u0026quot;文档注释\u0026quot;，可以像官方注释一样生成代码文档，也可以在检查器(Inspector)中鼠标悬停显示注释内容。\nextends Node2D ## 这是个变量的文档注释 @export var a = 1 ## 这是个函数上的文档注释 func test_function(): pass 数据类型\r#\rGodot 内置一些数据类型，分为基本数据类型(int、float、String、bool等)和对象数据类型(Dictionary、Array等)。基本数据类型在当作参数传递的时候是\u0026quot;按值传递\u0026quot;。对象数据类型在当作参数传递的时候是\u0026quot;引用传递\u0026quot;。\n数字类型\r#\r整数类型\r#\rvar n = 1 var n1 : int = 2 int 存储的是 64 位值，等效于 C++ 中的 int64_t\n浮点数类型\r#\rvar f = 1.1 var f1 :float = 1.2 float 存储的是 64 位值，等效于 C++ 中的 double。\n字符类型\r#\rvar s = \u0026#34;Hello Godot!\u0026#34; var s1 : String = \u0026#34;Hello Godot!\u0026#34; 默认使用 Unicode 字符。\n布尔类型\r#\rvar b = false var b1 : bool = true 字典类型\r#\rvar dict = {\u0026#34;key\u0026#34;: \u0026#34;value\u0026#34;, 2: 3} var dict1 : Dictionary = {key = \u0026#34;value\u0026#34;, other_key = 2} # 返回该字典中键为 key 的值 var v1 = dict.get(\u0026#34;key\u0026#34;) print(v1) # 输出 value # 如果字典中没有名为 key1 的键，返回 null var v2 = dict.get(\u0026#34;key1\u0026#34;) print(v2) # 输出 null # 不存在的时候返回某个默认值 var v3 = dict.get(\u0026#34;key1\u0026#34;,\u0026#34;default value\u0026#34;) print(v3) # 输出 default value # 合并两个字典 dict.merge(dict1) # 将 dict1 中的值合并到 dict 中 var v4 = dict.get(\u0026#34;other_key\u0026#34;) print(v4) # 输出 2 # 移除键值 dict.erase(\u0026#34;other_key\u0026#34;) var v5 = dict.get(\u0026#34;other_key\u0026#34;) print(v5) # 输出 null # 添加键值 dict[\u0026#34;other_key\u0026#34;] = \u0026#34;new_value\u0026#34; var v6 = dict.get(\u0026#34;other_key\u0026#34;) print(v6) # 输出 new_value # 更新某个键的值 dict[\u0026#34;other_key\u0026#34;] = \u0026#34;updated_value\u0026#34; var v7 = dict.get(\u0026#34;other_key\u0026#34;) print(v7) # 输出 updated_value 字典的值类型可以是任何类型。\n数组\r#\rvar arr = [1, 2, 3] var arr1 : Array = [\u0026#34;string1\u0026#34;,\u0026#34;string2\u0026#34;,\u0026#34;string3\u0026#34;] # 添加值 arr.append(4) print(arr) # 输出：[1, 2, 3, 4] # 更新 arr[0] = -1 # 将索引为 0 位置的值改成 -1 print(arr) # 输出：[-1, 2, 3, 4] # 取某个位置的值 var v1 = arr[1] print(v1) # 输出：2 # 移除某个值 arr.remove_at(0) # 移除索引为 0 位置的值 print(arr) # 输出：[2, 3, 4] # 合并数组 arr.append_array(arr1) print(arr) # 输出：[2, 3, 4, \u0026#34;string1\u0026#34;, \u0026#34;string2\u0026#34;, \u0026#34;string3\u0026#34;] 数组设置类型\r#\r上面的例子可以看出默认的 Array 类型是可以储存不同的数据类型，如果想只存某种类型可以使用“类型化数组”。\n# 只能存 int 类型 var a: Array[int] # 只能存 Node 类型 var b: Array[Node] # 只能存某种枚举类型 var d: Array[MyEnum] Array 等价于 Array[Varaint]\n压缩数组\r#\r如果读者需要使用数组存储较多的值（数万个），建议使用压缩数组。压缩数组可以避免内存碎片，从而降低内存的使用量。但是压缩数组比普通的数组性能要低一点，所以不建议小数据集的时候使用压缩数组。\nvar arr : PackedInt64Array = [1,2,3] print(arr) # 输出：[1, 2, 3] var arr1 : PackedStringArray = [\u0026#34;string1\u0026#34;,\u0026#34;string2\u0026#34;,\u0026#34;string3\u0026#34;] print(arr1) # 输出：[\u0026#34;string1\u0026#34;, \u0026#34;string2\u0026#34;, \u0026#34;string3\u0026#34;] PackedByteArray：字节（从 0 到 255 的整数）数组。 PackedInt32Array：32位整数数组。 PackedInt64Array：64位整数数组。 PackedFloat32Array：32位浮点数数组。 PackedFloat64Array：64位浮点数数组。 PackedStringArray：字符串数组。 PackedVector2Array：Vector2 类型的数组。 PackedVector3Array：Vector3 类型的数组。 PackedColorArray：Color 类型的数组。 运算\r#\r数值运算\r#\rvar n1 = 1 var n2 = 2 # 加 var n3 = n1 + n2 print(n3) # 输出 3 # 减 var n4 = n1 - n2 print(n4) # 输出 -1 # 乘 var n5 = n1 * n2 print(n5) # 输出 2 # 除 var n6 = 1.0 / 2.0 print(n6) # 输出 0.5 # 取余 var n7 = 10 % 3 print(n7) # 输出 1 枚举\r#\rextends Node2D # 匿名枚举类型 enum {UNIT_NEUTRAL, UNIT_ENEMY, UNIT_ALLY} # 一个名称为 Name 的枚举 enum Name {THING_1, THING_2, ANOTHER_THING = -1} func _ready(): print(UNIT_NEUTRAL) # 输出：0 print(Name.THING_1) # 输出：0 print(Name.ANOTHER_THING) # 输出：-1 枚举类型实际上存的的是就是数字类型，一些地方使用枚举类型可以提高性能和可维护性。\n循环语句\r#\r程序中经常会用到迭代一个范围或者一个数组、字典类型的时候。\n# for 语句迭代数组 for i in [1,2,3,4,5]: print(i) # 输出 ： # 1 # 2 # 3 # 4 # 5 # for 语句迭代数组 var arr = [\u0026#39;h\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;] for i in arr.size(): print(arr[i]) # 输出： # h # e # l # l # o # for 语句迭代字典 var dic = {\u0026#34;a\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;b\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;c\u0026#34;: \u0026#34;2\u0026#34;} for i in dic: print(i + \u0026#34;=\u0026#34; + dic[i]) # 输出 # a=0 # b=1 # c=2 # for 语句迭代一定次数 for i in range(3): print(i) # 输出 ： # 0 # 1 # 2 # 其实 range(3) 返回的就是一个有三个元素的（[0,1,2]）的数组 # range 方法可以有很多玩法，读者感兴趣可以取看下 range 的文档。 # for 语句迭代字符 for c in \u0026#34;hello\u0026#34;: print(c) # 输出： # h # e # l # l # o 条件语句\r#\r根据不同的条件执行不同的代码。\nIf 语句\r#\r# if...else... var x = 1 if x == 1: print(\u0026#34;x = 1 时会执行这里\u0026#34;) else: print(\u0026#34;x 不等于 1 时会执行这里\u0026#34;) # if...elif... var x = 2 if x == 1: print(\u0026#34;x = 1 时会执行这里\u0026#34;) elif x == 2: print(\u0026#34;x 等于 2 时会执行这里\u0026#34;) else: print(\u0026#34;x 不等于 1 且 x 不等于 2 时会执行这里\u0026#34;) # 类三运算符（这个还是挺常用的） var x = 2 var y = 1111 if x == 1 else 1111 print(y) # 输出：1111 Match 语句\r#\r默认情况下 Match 语句按照代码顺序，只要匹配到一个分支，下面分支就不会执行了。\n# 值匹配 var x = 1 match x: 1: print(\u0026#34;x = 1 时会执行这里\u0026#34;) 2: print(\u0026#34;x = 2 时会执行这里\u0026#34;) \u0026#34;test\u0026#34;: print(\u0026#34;x = test 时会执行这里\u0026#34;) _: # 这里的 _ 相当于 default(默认值)，只有上面的都没匹配到才会走这里，可以省略。 print(\u0026#34;上面都没匹配会执行到这里\u0026#34;) # 多重匹配 var x = 1 match x: 1,2,3,4: print(\u0026#34;x 的值是 1或2或3或4\u0026#34;) _: print(\u0026#34;x 不等于 1，2，3，4 中的任何一个\u0026#34;) # 类型匹配 var x :int= 1 match typeof(x): TYPE_INT: print(\u0026#34;x 是 int 类型的时候执行这里\u0026#34;) TYPE_STRING: print(\u0026#34;x 是 string 类型的时候执行这里\u0026#34;) TYPE_ARRAY: print(\u0026#34;x 是数组的时候执行这里\u0026#34;) _: print(\u0026#34;上面都没匹配会执行到这里\u0026#34;) # 绑定模式 var x = 3 match x: 1: print(\u0026#34;x = 1 时会执行这里\u0026#34;) 2: print(\u0026#34;x = 2 时会执行这里\u0026#34;) var new_x: # 只有上面都没匹配到才会走到这里，并将 x 的值赋给 new_x print(\u0026#34; new_x 的值为 \u0026#34;,new_x) # 输出：new_x 的值为 3 Match 数组\nvar arr = [1,2,3] match arr: []: # 当 arr 是空的时候执行这里 print(\u0026#34;arr 是空\u0026#34;) [1,null]: # 当 arr 全等于 [1,null] 的时候执行这里 print(\u0026#34;arr = [1,null]\u0026#34;) [var start, _, \u0026#34;test\u0026#34;]: # 当 数组长为 3 ，第二个值为人一直，第三个值为\u0026#34;test\u0026#34;的时候执行这里 # 并且 start 会被复制数组的第一个值 print(start) [1 , ..]: # 当数组的第一个值是 1 的时候执行这里 print(\u0026#34; arr 的第一个值是 1\u0026#34;) Match 字典\nvar dic = {\u0026#34;name\u0026#34;:\u0026#34;zhangsan\u0026#34;,\u0026#34;age\u0026#34;:11} match dic: {}: print(\u0026#34;dic 是空的\u0026#34;) {\u0026#34;name\u0026#34;:\u0026#34;zhangsan\u0026#34;}: # dic 中只有一个 name 主键，并且对应的值是 zhangsan # 满足上面条件才会执行这里的代码 print(\u0026#34;dic 中 name 的值是 zhangsan\u0026#34;) {\u0026#34;name\u0026#34;: \u0026#34;zhangsan\u0026#34;, \u0026#34;age\u0026#34;: var age}: # dic 中只有 name 主键和 age 主键，且 name 对应的值为 zhangsan # 满足上面的条件才会执行这里的代码，且 age 的值为 dic 中 age 对应的值 print(\u0026#34;dic 中 age 的值是 \u0026#34;,age) {\u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;}: # dic 中只有 name 主键和 age 主键才会执行这里 print(\u0026#34;dic 中只含有 name 和 age 两个键值\u0026#34;) {\u0026#34;name\u0026#34;: \u0026#34;lisi\u0026#34;, ..}: # dic 中只要含有 name 且对应的值为 lisi，才会走这里 print(\u0026#34;dic 中 name 的值为 lisi\u0026#34;) 类型转换\r#\r如果需要将值强制转换为特定类型，特别是对于对象类型而言需要进行转型，则可以使用强制转型运算符 as。\n# 创建一个 sprite2D 类型 var sprite : Sprite2D = Sprite2D.new() # 将上面的 sprite 转换成 Node2D 类型 var node2d : Node2D = sprite as Node2D 类\r#\r默认情况下，所有脚本文件都是未命名的类，这时只能使用文件的路径来引用这些无名类。\nMyClass.gd 文件\nextends Node Node2D.gd 文件\nextends Node2D func _ready(): var myclass = load(\u0026#34;res://MyClass.gd\u0026#34;) var myclassObj = myclass.new() print(\u0026#34;success\u0026#34;) 可以通过 class_name 给自定义类起个类名，就可以通过类名创建对象了。\nMyClass.gd 文件\nclass_name MyClass extends Node Node2D.gd 文件\nextends Node2D func _ready(): var myclassObj = MyClass.new() print(\u0026#34;success\u0026#34;) 函数/方法\r#\r函数始终属于类。查找变量时，函数作用域的查找顺序是：局部 → 类成员 → 全局。\nfunc _ready(): var res = my_func(1,2) print(\u0026#34; x + y = \u0026#34;,res) # 输出： x + y = 3 # 自定义函数，函数名为 my_func 。 # 这个函数用于计算 x + y func my_func(x : int , y : int) -\u0026gt; int: return x + y 上面的 my_func 是有返回值的，有时候需要不需要返回的的函数。\nfunc _ready(): my_func(1,2) # 输出： x + y = 3 # 自定义函数，函数名为 my_func 。 # 这个函数用于计算 x + y func my_func(x : int , y : int) : var res = x + 1 print(\u0026#34; x + y = \u0026#34;,res) 参数 x 和 y 可以设置默认值。\nfunc _ready(): # 此处只传第一个参数， x = 2 ，y 则取的默认值 my_func(2) # 输出： x + y = 4 # 自定义函数，函数名为 my_func 。 # 这个函数用于计算 x + y func my_func(x : int = 1, y : int = 2) : var res = x + 1 print(\u0026#34; x + y = \u0026#34;,res) 引用函数\r#\r引用函数就是将一个函数当作参数传给另一个函数，使用关键字 Callable。\nfunc _ready(): var res = my_func(1,2,add_func) print(\u0026#34;x + y = \u0026#34;,res) # 输出： x + y = 3 # 自定义函数，函数名为 my_func 。 func my_func(x : int , y : int , other_func : Callable) : # 直接调用 Callable 的 call() 方法，而不能直接用 () return other_func.call(x,y) # 将这个函数当作参数传给上面那个函数 func add_func(x : int , y : int) -\u0026gt; int: return x + y Lambda 函数\r#\rlambda 函数可以用来创建不属于类的函数。比如创建一些 Callable 对象并当作参数传给其他函数的时候很有用。\nfunc _ready(): # 定义lambda 函数 var lambda_func = func (x : int , y : int): var res = x + y print(\u0026#34;x + y = \u0026#34;,res) # 调用 lambda 函数 lambda_func.call(1,2) # 输出：x + y = 3 也可以个 lambda 函数设置个函数名。\nfunc _ready(): # 创建 lambda 函数，并给其设置个名字my_lambda_func var lambda_func = func my_lambda_func (x : int , y : int): var res = x + y print(\u0026#34;x + y = \u0026#34;,res) # 调用 lambda 函数 lambda_func.call(1,2) # 输出：x + y = 3 lambda 函数不能是静态函数。\n静态函数\r#\r函数可以声明为静态函数。静态函数不能访问实例成员变量，也不能使用 self，适用于创建辅助函数工具库。\nUtils.gd 文件\nclass_name Utils extends Node # 静态方法 static func my_sum_func(x : int , y :int) -\u0026gt; int: return x + y Node2D.gd 文件\nextends Node2D func _ready(): # 调用上面 Utils.gd 中定义的静态方法 var res = Utils.my_sum_func(1,2) print(\u0026#34;x + y = \u0026#34;,res) # 输出：x + y = 3 构建函数\r#\r"},{"id":6,"href":"/docs/tips/","title":"Godot 小技巧","section":"Docs","content":"\rGodot 游戏引擎一些小技巧\r#\r"},{"id":7,"href":"/docs/nodes/tilemap/","title":"TileMap","section":"Godot节点手册","content":"\rTileMap\r#\rTileMap 是用户创建游戏布局的图块网格。相比使用大量的 Sprite2D 布置场景，使用 TileMap 更方便游戏的性能也更好。可以将其理解为一个巨大的网格，这个网格中每个单元都可以放置不同的图块，以此来布置你的场景。\nTileMap 需要内嵌一个 TileSet（见 TileSet 章节），可以理解为 TileMap 是一张画纸而 TileSet 是一个画笔，而在 TileSet 中添加的图集资源可以理解为颜料。\n使用 TileMap\r#\r给 TileMap 设置完 TileSet 就可以在 TileMap 上绘制场景了。\n设置 TileSet ：\n1、添加 TileSet。 2、打开 TileSet 窗口，编辑 TileSet。 3、导入图集资源。 TileMap 绘制工具\r#\r点击右下角的 TileMap 打开编辑窗口，使用绘制工具就可以绘制场景了。\n工具栏有几个工具可以方便我们绘制场景。\n选择工具，可以框选多个图集（多选）。 单个绘制工具，在 TileMap 窗口（中下部分）选择你要绘制的图块，在 2D 窗口（中上部分）就可以绘制了。 直线绘制工具。 矩形绘制工具。 填充工具。这个工具会将某个区域填充成同一个图块。 选择工具。这个工具可以选择某个区域的图块，省的到 TileMap 窗口中选择了。 清除工具。清除已经绘制的部分。 随机图块。如果有一个草坪要绘制，然后有多种草的图块样式，就可以使用这个工具，他会随机在 TileMap 上绘制草，水机绘制看上去会更自然。 TileMap 多层\r#\rTileMap 支持多层，比如一个场景。第一层是土地，第二层是草地，第三层上放置一些时候。\n点击 TileMap ，在右侧的检查器窗口中 layers 属性中添加元素。然后再 TileMap 编辑窗口中可以选择不同的图层就可以在相应的图层上绘制了。\n"},{"id":8,"href":"/docs/nodes/tilemaplayer/","title":"TileMapLayer","section":"Godot节点手册","content":"\rTileMapLayer\r#\rTileMapLayer 是 Godot4.3 新增的节点，用于替换旧版本的 TileMap 节点（tilemap已经从4.3开始被废弃）。\nTileMapLayer 与 TileMap 用法上差不多，可以理解为后者是前者的一个集合，也就是 TileMap 有多层，而 TileMapLayer 只有一层。\nTileMap\r#\r"},{"id":9,"href":"/docs/nodes/tileset/","title":"TileSet","section":"Godot节点手册","content":"\rTileSet\r#\rTileSet 是一个图块集，也就是能放置到 TileMap (或者TileMapLayer)上的图块的集合。\n创建 TileSet 可以借助 TileMap 的检查器窗口。\n如果想要重复使用，可以点击 TileSet 那行最右边的向下的小三角点击“保存”，下次别的TileMap使用的时候点击加载就行了。\n设置 TileSet 属性\r#\r创建完 TileSet 有几个基本属性\nTile Shape ：每个图块单元的形状，默认的是 Square(正方形)。还有其他形状，比如：Isometric(等角)、Hexagon(五边型)等。 Tile Layout：图块的布局方式。 Tile Offset Axis：图块偏移轴，可以水平偏移或者垂直偏移。 Tile Size ： 每个图块的大小，这个一般跟 TileMap 的 cell quadrant size 属性一样。 设置 TileSet 图块\r#\r点击新建的 TileSet（1） 会在下面出现个设置图块的窗口（2）。将准备好的图块资源拖拽到图块窗口中（3）。\n如上图， TileSet 已经将 icon.svg 平均分成 16x16 大小的图块，然后我们就可以单独的将这些图块放到 TileMap 上了。\n"},{"id":10,"href":"/docs/case/","title":"Godot 游戏案例","section":"Docs","content":"\rGodot 游戏案例\r#\r平台跳跃游戏\r#\r待完善\u0026hellip;\n2D RGB游戏\r#\r待完善\u0026hellip;\n3D FPS 游戏\r#\r待完善\u0026hellip;\n类八方旅人游戏\r#\r待完善\u0026hellip;\n"},{"id":11,"href":"/docs/nodes/tween/","title":"Tween","section":"Godot节点手册","content":"\rTween\r#\rTween【/twiːn/ 在……之间】是用于创建“补间动画”的类。\n如果笔者想在 Godot 中创建一个动画，可能首先会想到用 AnimationPlayer 或者 AnimatedSprite/2D 来创建，但是这两个必须在编辑器里事先设置好动画。\n对于一些未知的动画，需要在代码中创建的简单动画，就可以使用 Tween 。而且 Tween 更轻量级，性能更好。\n案例\r#\r在此案例中，我们使用 Tween 将下列的序列帧生成动画。\n创建 Sprite2D 节点。 将动画资源设置到 texture 上（这里要把hframes设置成6，图中没体现出来）。 给 Sprite2D 添加代码。 在 func _ready(): 中编写代码，创建动画。 代码如下：\nfunc _ready(): # 创建 tween var tween = create_tween() # 设置重复次数，这个方法如果不传数字则代表循环无限次 tween.set_loops() # 将 sprite2D 的 frame 从默认值（0）变成 5，中间的 1，2，3，4 由 tween 自动补充 # self 指的是当前的脚本所属的 sprite2D 节点对象 tween.tween_property(self,\u0026#34;frame\u0026#34;,5,0.3) # 上面的动画播放完，调用 reset_frame 将 frame 设置成0，供下次循环使用 tween.tween_callback(reset_frame) # 将 sprite2D 的 frame 帧属性设置成0 func reset_frame() : frame = 0 参考\r#\r一些用 Tween 实现小动画参考。\n移动动画\r#\r# 1s 将节点从当前位置沿 x 轴向左移动 100 个单位。 var tween = create_tween() tween.tween_property(self,\u0026#34;position\u0026#34;,self.position + Vector2(100,0),1) # 1s 将节点从当前位置沿 y 轴向下移动 100 个单位。 var tween = create_tween() tween.tween_property(self,\u0026#34;position\u0026#34;,self.position + Vector2(0,100),1) 旋转动画\r#\r# 1s 顺时针旋转 180 度 var tween = create_tween() tween.tween_property(self,\u0026#34;rotation\u0026#34;,Vector2(-1,0).angle(),1) # 1s 逆时针旋转 180 度 var tween = create_tween() tween.tween_property(self,\u0026#34;rotation\u0026#34;,- Vector2(-1,0).angle(),1) 这里 Vector2(-1,0).angle() 是根据向量计算角度。如果使用小数，可能会得到意料之外的结果。\n淡入淡出动画\r#\r# 1s 淡出 var tween = create_tween() tween.tween_property(self,\u0026#34;modulate\u0026#34;,Color.TRANSPARENT,1) # 1s 淡入 var tween = create_tween() tween.tween_property(self,\u0026#34;modulate\u0026#34;,Color.WHITE,1) 方法调用\r#\r可以用 tween 调用方法，补间的值就是函数的传参。\nfunc _process(delta): # 按下空格键， tween 会调用 test_func 方法 # 传的 x 参数是 0-1 if Input.is_action_just_pressed(\u0026#34;ui_accept\u0026#34;): var tween = create_tween() tween.tween_method(test_func, 0, 10, 1) # 打印 x func test_func(x : float) -\u0026gt; void: print(x) 动画结束回调函数\r#\rfunc _process(delta): if Input.is_action_just_pressed(\u0026#34;ui_accept\u0026#34;): var tween = create_tween() # 1s 向右移动 10个单位 tween.tween_property(self,\u0026#34;position\u0026#34;,self.position + Vector2(10,0),1) # 动画结束调用 tween_finished tween.tween_callback(tween_finished) func tween_finished() -\u0026gt; void: print(\u0026#34;tween finished!\u0026#34;) 参考及资源\r#\r官方教程\n像素资源-Animated Pixel Adventurer\n"},{"id":12,"href":"/docs/nodes/","title":"Godot节点手册","section":"Docs","content":"\rGodot Engine 节点\r#\r"}]